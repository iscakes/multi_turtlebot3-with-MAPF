# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from robint_msgs/ErrorCode.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class ErrorCode(genpy.Message):
  _md5sum = "45cd9bc105f86c67f47b4756c85f449a"
  _type = "robint_msgs/ErrorCode"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """# Task Command Error Code
uint8 NONE = 0
uint8 ANOTHER_TASK_IS_RUNNING = 1
uint8 CURRENT_TASK_IS_RUNNING = 2
uint8 NO_TASK_IS_RUNNING = 3

uint8 GLOBAL_PLAN_FAILURE = 11

uint8 SET_MAP_FAILURE = 41
uint8 RESET_ODOM_FAILURE = 42
uint8 RESET_IMU_FAILURE = 43
uint8 RESET_EKF_FAILURE = 44

uint8 LOCALIZATION_ERROR = 50

# AutoCharge Error Code
uint8 LOCATION_UUID_NOT_CHARGE_BASE = 61
uint8 CHARGE_BASE_EMPTY = 62
uint8 DEFAULT_CHARGE_BASE_NOT_SET = 63

# AutoExplore Error Code
uint8 CHARGE_DETECTION_FAILURE = 70

# Map Widget Operation Error Code
uint8 MAP_IMAGE_FILE_NON_EXISTENT = 100
uint8 MAP_UUID_NON_EXISTENT = 101
uint8 MAP_UUID_NOT_CURRENT = 102
uint8 GET_MAP_OCCUPANCY_GRID_FAILURE = 103
uint8 LOAD_MAP_FAILURE = 104
uint8 CURRENT_MAP_UUID_EMPTY = 105
uint8 UUID_NON_EXISTENT = 106

uint8 RECORDED_TRAJECTORY_CHECK_FAILURE = 107
uint8 TRAJECTORY_TOO_SHORT = 108
uint8 AREA_TOO_SMALL = 109
uint8 POLYGON_NON_SIMPLE = 110
uint8 POLYGON_NON_CLOSED = 111
uint8 REQUESTED_INDEX_OUT_OF_RANGE = 112

uint8 LOCATION_UUID_NON_EXISTENT = 121

uint8 VIRTUALWALL_UUID_NON_EXISTENT = 141

uint8 ZONE_UUID_NON_EXISTENT = 151
uint8 CLEANING_PATH_NON_EXISTENT = 152


uint8 ARGUMENT_ERROR = 253
uint8 DATA_ERROR = 254
uint8 ROS_ERROR = 255





"""
  # Pseudo-constants
  NONE = 0
  ANOTHER_TASK_IS_RUNNING = 1
  CURRENT_TASK_IS_RUNNING = 2
  NO_TASK_IS_RUNNING = 3
  GLOBAL_PLAN_FAILURE = 11
  SET_MAP_FAILURE = 41
  RESET_ODOM_FAILURE = 42
  RESET_IMU_FAILURE = 43
  RESET_EKF_FAILURE = 44
  LOCALIZATION_ERROR = 50
  LOCATION_UUID_NOT_CHARGE_BASE = 61
  CHARGE_BASE_EMPTY = 62
  DEFAULT_CHARGE_BASE_NOT_SET = 63
  CHARGE_DETECTION_FAILURE = 70
  MAP_IMAGE_FILE_NON_EXISTENT = 100
  MAP_UUID_NON_EXISTENT = 101
  MAP_UUID_NOT_CURRENT = 102
  GET_MAP_OCCUPANCY_GRID_FAILURE = 103
  LOAD_MAP_FAILURE = 104
  CURRENT_MAP_UUID_EMPTY = 105
  UUID_NON_EXISTENT = 106
  RECORDED_TRAJECTORY_CHECK_FAILURE = 107
  TRAJECTORY_TOO_SHORT = 108
  AREA_TOO_SMALL = 109
  POLYGON_NON_SIMPLE = 110
  POLYGON_NON_CLOSED = 111
  REQUESTED_INDEX_OUT_OF_RANGE = 112
  LOCATION_UUID_NON_EXISTENT = 121
  VIRTUALWALL_UUID_NON_EXISTENT = 141
  ZONE_UUID_NON_EXISTENT = 151
  CLEANING_PATH_NON_EXISTENT = 152
  ARGUMENT_ERROR = 253
  DATA_ERROR = 254
  ROS_ERROR = 255

  __slots__ = []
  _slot_types = []

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(ErrorCode, self).__init__(*args, **kwds)

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      pass
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      pass
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
